name: Main - Merge

on:
  workflow_dispatch:
  schedule:
    - cron: '0 0 * * *'
  push:
    branches:
      - main
  pull_request:
    branches:
      - main

jobs:
  merge-fido-data:
    runs-on: ubuntu-latest

    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        ref: main

    - name: Install PSParseHTML Module
      shell: pwsh
      run: Install-Module -Name PSParseHTML -Force -Scope CurrentUser

    - name: Run Merge-GHFidoData Script
      id: merge_script
      shell: pwsh
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        GITHUB_REPOSITORY: ${{ github.repository }}
      run: |
        Import-Module PSParseHTML
        . ./Scripts/Test-GHValidVendor.ps1
        . ./Scripts/Test-GHAAGUIDExists.ps1
        . ./Scripts/Export-GHEntraFido.ps1
        . ./Scripts/Merge-GHFidoData.ps1
        Merge-GHFidoData

    - name: Read Environment Variables
      shell: bash
      run: |
        if [ -f ./Scripts/env_vars.txt ]; then
          echo "Setting environment variables from env_vars.txt"
          cat ./Scripts/env_vars.txt >> $GITHUB_ENV
        else
          echo "env_vars.txt not found."
        fi

    - name: Debug - Display ISSUE_ENTRIES, KEYS_NOW_VALID, and VENDORS_NOW_VALID Environment Variables
      shell: bash
      run: |
        echo "ISSUE_ENTRIES: $ISSUE_ENTRIES"
        echo "KEYS_NOW_VALID: $KEYS_NOW_VALID"
        echo "VENDORS_NOW_VALID: $VENDORS_NOW_VALID"

    - name: Close Fixed Issues and Create New Issues
      uses: actions/github-script@v6
      with:
        github-token: ${{ secrets.GITHUB_TOKEN }}
        script: |
          const fs = require('fs');
          
          // Load FidoKeys.json to check current vendor status
          const fidoKeysData = JSON.parse(fs.readFileSync('Assets/FidoKeys.json', 'utf8'));
          
          const issueEntriesRaw = process.env.ISSUE_ENTRIES || '';
          const issueEntries = issueEntriesRaw.split('%0A').map(entry => decodeURIComponent(entry)).filter(entry => entry.trim() !== '');
          
          // Remove duplicates from issueEntries
          const uniqueIssueEntries = [...new Set(issueEntries)];
          
          if (uniqueIssueEntries.length === 0) {
            console.log('No new issue entries found.');
          } else {
            console.log(`Processing ${uniqueIssueEntries.length} unique issue entries`);
            
            // Fetch all open auto-generated issues once
            const { data: allOpenIssues } = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
              labels: 'auto-generated',
              per_page: 100,
            });
            
            for (const entry of uniqueIssueEntries) {
              const parts = entry.split('|');
              if (parts.length < 2) {
                console.error(`Invalid entry format: ${entry}`);
                continue;
              }
              const [issueTitle, issueBody, issueLabel] = parts;
              console.log(`Processing issue: ${issueTitle}`);
              
              // Check if issue already exists in the fetched list
              const existingIssue = allOpenIssues.find(issue => issue.title === issueTitle);
              if (!existingIssue) {
                const assignees = [];
                if (issueLabel === 'InvalidVendor' || issueLabel === 'DuplicateEntry') {
                  assignees.push('DevClate');
                }
                await github.rest.issues.create({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  title: issueTitle,
                  body: issueBody,
                  labels: issueLabel ? ['auto-generated', issueLabel] : ['auto-generated'],
                  assignees: assignees,
                });
                console.log(`Issue created: ${issueTitle}`);
              } else {
                console.log(`Issue already exists: ${issueTitle}`);
              }
            }
          }

          // Check all InvalidVendor issues and close those that are now valid or are duplicates
          console.log('Checking all InvalidVendor issues for validation status and duplicates...');
          const { data: invalidVendorIssues } = await github.rest.issues.listForRepo({
            owner: context.repo.owner,
            repo: context.repo.repo,
            state: 'open',
            labels: ['auto-generated', 'InvalidVendor'],
            per_page: 100,
          });
          
          console.log(`Found ${invalidVendorIssues.length} open InvalidVendor issues`);
          
          // Group issues by AAGUID to find duplicates
          const issuesByAAGUID = {};
          for (const issue of invalidVendorIssues) {
            const aaguidMatch = issue.title.match(/AAGUID\s+([a-f0-9-]+)/i);
            if (aaguidMatch) {
              const aaguid = aaguidMatch[1];
              if (!issuesByAAGUID[aaguid]) {
                issuesByAAGUID[aaguid] = [];
              }
              issuesByAAGUID[aaguid].push(issue);
            }
          }
          
          // Process each AAGUID group
          for (const [aaguid, issues] of Object.entries(issuesByAAGUID)) {
            console.log(`Checking AAGUID ${aaguid} with ${issues.length} issue(s)`);
            
            // Sort issues by creation date (oldest first)
            issues.sort((a, b) => new Date(a.created_at) - new Date(b.created_at));
            
            // Find the key in FidoKeys.json
            const key = fidoKeysData.keys.find(k => k.AAGUID === aaguid);
            
            if (key) {
              console.log(`Found key: Vendor='${key.Vendor}', ValidVendor='${key.ValidVendor}'`);
              
              // Check if vendor is now valid - close ALL issues for this AAGUID
              if (key.ValidVendor === 'Yes') {
                console.log(`Vendor is now valid for AAGUID ${aaguid}. Closing all ${issues.length} issue(s)`);
                for (const issue of issues) {
                  await github.rest.issues.update({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: issue.number,
                    state: 'closed',
                    state_reason: 'completed',
                  });
                  await github.rest.issues.createComment({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: issue.number,
                    body: `The vendor for key with AAGUID '${aaguid}' is now valid (Vendor: ${key.Vendor}). This issue is being closed automatically.`,
                  });
                  console.log(`Closed issue #${issue.number} for AAGUID: ${aaguid}`);
                }
              } else if (issues.length > 1) {
                // Vendor still invalid but we have duplicates - close all except the oldest
                console.log(`Found ${issues.length} duplicate issues for AAGUID ${aaguid}. Keeping oldest (#${issues[0].number}), closing ${issues.length - 1} duplicates`);
                for (let i = 1; i < issues.length; i++) {
                  await github.rest.issues.update({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: issues[i].number,
                    state: 'closed',
                    state_reason: 'not_planned',
                  });
                  await github.rest.issues.createComment({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: issues[i].number,
                    body: `Closing as duplicate. This issue is tracked in #${issues[0].number}`,
                  });
                  console.log(`Closed duplicate issue #${issues[i].number} for AAGUID: ${aaguid}`);
                }
              } else {
                console.log(`Vendor still invalid for AAGUID ${aaguid}. Keeping issue #${issues[0].number} open.`);
              }
            } else {
              console.log(`AAGUID ${aaguid} not found in FidoKeys.json`);
            }
          }

    - name: Display Merge Log
      shell: bash
      run: |
        echo "Extracting newest 3 entries from merge_log.md"

        # Extract the first 3 '# Merge Log -' sections
        awk '/^# Merge Log -/{n++; if(n>3) exit} {print}' merge_log.md > newest_merge_log_entries.txt

        # Adjust header levels from '#' to '###' to fit within the summary
        sed 's/^# /### /' newest_merge_log_entries.txt > temp_merge_log_entries.txt

        # Append to GitHub Action Summary without code block
        echo "## Merge Log - Newest 3 Entries" >> $GITHUB_STEP_SUMMARY
        cat temp_merge_log_entries.txt >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY

        # Clean up temporary files
        rm temp_merge_log_entries.txt newest_merge_log_entries.txt

    - name: Display Detailed Log
      shell: bash
      run: |
        echo "Extracting the 3 newest entries from detailed_log.txt"

        # Extract the first 3 'Detailed Log -' sections
        awk '/^Detailed Log -/{n++; if(n>3) exit} {print}' detailed_log.txt > newest_detailed_log_entries.txt

        # Append to GitHub Action Summary
        echo "## Detailed Log - Newest 3 Entries" >> $GITHUB_STEP_SUMMARY
        echo '```' >> $GITHUB_STEP_SUMMARY
        cat newest_detailed_log_entries.txt >> $GITHUB_STEP_SUMMARY
        echo '```' >> $GITHUB_STEP_SUMMARY

        # Clean up temporary file
        rm newest_detailed_log_entries.txt

    - name: Configure Git
      run: |
        git config --global user.name 'DevClate'
        git config --global user.email 'clate@clatent.com'

    - name: Commit changes
      run: |
        git add Assets/FidoKeys.json merge_log.md detailed_log.txt
        git commit -m "Update FidoKeys.json, merge_log.md, and detailed_log.txt" || echo "No changes to commit"

    - name: Fetch and rebase origin/main
      run: |
        git fetch origin main
        git rebase origin/main

    - name: Push changes
      uses: ad-m/github-push-action@v0.6.0
      with:
        github_token: ${{ secrets.GITHUB_TOKEN }}
        branch: main